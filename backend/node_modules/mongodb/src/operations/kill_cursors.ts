import type { Long } from '../bson';
<<<<<<< HEAD
import { MongoRuntimeError } from '../error';
import type { Server } from '../sdam/server';
import type { ClientSession } from '../sessions';
import { type TimeoutContext } from '../timeout';
import { type MongoDBNamespace, squashError } from '../utils';
=======
import { type Connection } from '../cmap/connection';
import { MongoDBResponse } from '../cmap/wire_protocol/responses';
import { type MongoError, MongoRuntimeError } from '../error';
import type { Server, ServerCommandOptions } from '../sdam/server';
import type { ClientSession } from '../sessions';
import { type TimeoutContext } from '../timeout';
import { type MongoDBNamespace } from '../utils';
>>>>>>> 1b03d93 (commit in korea)
import { AbstractOperation, Aspect, defineAspects, type OperationOptions } from './operation';

/**
 * https://www.mongodb.com/docs/manual/reference/command/killCursors/
 * @internal
 */
interface KillCursorsCommand {
  killCursors: string;
  cursors: Long[];
  comment?: unknown;
}

<<<<<<< HEAD
export class KillCursorsOperation extends AbstractOperation {
=======
export class KillCursorsOperation extends AbstractOperation<void> {
  override SERVER_COMMAND_RESPONSE_TYPE = MongoDBResponse;
>>>>>>> 1b03d93 (commit in korea)
  cursorId: Long;

  constructor(cursorId: Long, ns: MongoDBNamespace, server: Server, options: OperationOptions) {
    super(options);
    this.ns = ns;
    this.cursorId = cursorId;
    this.server = server;
  }

  override get commandName() {
    return 'killCursors' as const;
  }

<<<<<<< HEAD
  override async execute(
    server: Server,
    session: ClientSession | undefined,
    timeoutContext: TimeoutContext
  ): Promise<void> {
    if (server !== this.server) {
      throw new MongoRuntimeError('Killcursor must run on the same server operation began on');
    }

=======
  override buildCommand(_connection: Connection, _session?: ClientSession): KillCursorsCommand {
>>>>>>> 1b03d93 (commit in korea)
    const killCursors = this.ns.collection;
    if (killCursors == null) {
      // Cursors should have adopted the namespace returned by MongoDB
      // which should always defined a collection name (even a pseudo one, ex. db.aggregate())
      throw new MongoRuntimeError('A collection name must be determined before killCursors');
    }

    const killCursorsCommand: KillCursorsCommand = {
      killCursors,
      cursors: [this.cursorId]
    };
<<<<<<< HEAD
    try {
      await server.command(this.ns, killCursorsCommand, {
        session,
        timeoutContext
      });
    } catch (error) {
      // The driver should never emit errors from killCursors, this is spec-ed behavior
      squashError(error);
    }
=======

    return killCursorsCommand;
  }

  override buildOptions(timeoutContext: TimeoutContext): ServerCommandOptions {
    return {
      session: this.session,
      timeoutContext
    };
  }

  override handleError(_error: MongoError): void {
    // The driver should never emit errors from killCursors, this is spec-ed behavior
>>>>>>> 1b03d93 (commit in korea)
  }
}

defineAspects(KillCursorsOperation, [Aspect.MUST_SELECT_SAME_SERVER]);
